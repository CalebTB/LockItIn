# Potluck Template - UI Implementation Plan

**Issues:** #71, #72
**Sprint:** 4, Week 7 (February 10-11, 2026)
**Estimated Time:** 9-11 hours total
**Focus:** Flutter UI, Collaborative Lists, Real-time Updates

---

## Overview

Implement the complete UI experience for Potluck/Friendsgiving template, including dish signup system, category management, dietary restrictions, and real-time collaborative list updates.

**Database Schema:** âœ… Already implemented (migration 018, `events.template_data` JSONB)
**Data Models:** âœ… Already implemented (`PotluckTemplateModel` with helper methods)
**What's Needed:** Flutter screens, widgets, providers, real-time subscriptions

---

## Research Findings Summary

### Existing Infrastructure

**Data Model** (`lib/data/models/event_template_model.dart`):
```dart
class PotluckTemplateModel extends EventTemplateModel {
  final int maxDishesPerPerson;      // Default: 2
  final bool allowDuplicates;        // Default: true
  final List<PotluckDish> dishes;    // Dish signups (JSONB array)

  // Helper methods already exist:
  // - addDish(), removeDish()
  // - getUserDishCount(userId)
  // - canUserAddDish(userId)
  // - isDishNameTaken(dishName)
  // - getDishesByCategory(category)
  // - getCategoryCounts()

  static const List<String> standardCategories = [
    'mains', 'sides', 'desserts', 'drinks', 'appetizers'
  ];
}

class PotluckDish {
  final String id;
  final String name;
  final String category;
  final String? description;
  final String? servingSize;
  final List<String> dietaryInfo;  // ['vegetarian', 'vegan', 'gluten-free']
  final String? claimedBy;
  final DateTime? claimedAt;
}
```

**Event Creation Screen:**
- Template chip "ğŸ¦ƒ Friendsgiving" already exists (line 741)
- `_applyTemplate()` creates `PotluckTemplateModel()` instance

**Best Practices from Research:**
- **SignUpGenius pattern**: Visual availability indicators (green, yellow, gray)
- **Real-time updates**: WebSocket subscriptions for collaborative claiming
- **Dietary icons**: Clear visual indicators for restrictions
- **Category sections**: Group dishes by meal course
- **Claiming interaction**: Tap to claim, confirmation dialog

---

## UI Components to Build

### 1. Potluck Configuration Sheet (Modal Bottom Sheet)

**Location:** `lib/presentation/widgets/templates/potluck_config_sheet.dart`

**Purpose:** Configure potluck settings after tapping "ğŸ¦ƒ Friendsgiving" template chip

**UI Structure:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Configure Potluck Event          [X]    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                          â”‚
â”‚  MAX DISHES PER PERSON                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ [1]  [2]  [3]  [No limit]         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  Selected: 2 dishes                      â”‚
â”‚                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                          â”‚
â”‚  DUPLICATE DISHES                        â”‚
â”‚  [âœ“] Allow multiple people to bring      â”‚
â”‚      the same dish                       â”‚
â”‚                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                          â”‚
â”‚  PRE-FILL COMMON DISHES?                 â”‚
â”‚  [ ] Add suggested dishes to get         â”‚
â”‚      started (e.g., stuffing, pie,       â”‚
â”‚      cranberry sauce)                    â”‚
â”‚                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚        Continue to Dishes     â†’    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Configuration Options:**
- **Max dishes per person**: 1, 2, 3, or unlimited
- **Allow duplicates**: Toggle whether multiple people can bring same dish
- **Pre-fill suggestions**: Option to add common potluck items

**Implementation:**
```dart
class PotluckConfigSheet extends StatefulWidget {
  final String groupId;
  final PotluckTemplateModel? existingTemplate;

  @override
  State<PotluckConfigSheet> createState() => _PotluckConfigSheetState();
}

class _PotluckConfigSheetState extends State<PotluckConfigSheet> {
  int _maxDishesPerPerson = 2;
  bool _allowDuplicates = true;
  bool _preFillSuggestions = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final appColors = context.appColors;

    return DraggableScrollableSheet(
      initialChildSize: 0.7,
      maxChildSize: 0.9,
      minChildSize: 0.5,
      builder: (context, scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
          ),
          child: Column(
            children: [
              _buildHeader(),
              Expanded(
                child: ListView(
                  controller: scrollController,
                  padding: EdgeInsets.all(AppSpacing.lg),
                  children: [
                    _buildMaxDishesSection(),
                    SizedBox(height: AppSpacing.xl),
                    _buildDuplicatesToggle(),
                    SizedBox(height: AppSpacing.xl),
                    _buildPreFillToggle(),
                  ],
                ),
              ),
              _buildContinueButton(),
            ],
          ),
        );
      },
    );
  }

  Widget _buildMaxDishesSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'MAX DISHES PER PERSON',
          style: TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.w600,
            color: appColors.textSecondary,
            letterSpacing: 0.5,
          ),
        ),
        SizedBox(height: AppSpacing.md),
        Row(
          children: [
            _buildMaxDishOption(1),
            SizedBox(width: AppSpacing.sm),
            _buildMaxDishOption(2),
            SizedBox(width: AppSpacing.sm),
            _buildMaxDishOption(3),
            SizedBox(width: AppSpacing.sm),
            _buildMaxDishOption(0, label: 'No limit'),
          ],
        ),
        SizedBox(height: AppSpacing.sm),
        Text(
          _maxDishesPerPerson == 0
            ? 'No limit on dishes per person'
            : 'Each person can sign up for $_maxDishesPerPerson ${_maxDishesPerPerson == 1 ? "dish" : "dishes"}',
          style: TextStyle(color: appColors.textSecondary),
        ),
      ],
    );
  }

  Widget _buildMaxDishOption(int value, {String? label}) {
    final isSelected = _maxDishesPerPerson == value;
    final displayLabel = label ?? value.toString();

    return Expanded(
      child: InkWell(
        onTap: () => setState(() => _maxDishesPerPerson = value),
        child: Container(
          padding: EdgeInsets.symmetric(vertical: AppSpacing.md),
          decoration: BoxDecoration(
            color: isSelected
              ? colorScheme.primary.withValues(alpha: 0.1)
              : appColors.cardBackground,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: isSelected ? colorScheme.primary : appColors.cardBorder,
              width: isSelected ? 2 : 1,
            ),
          ),
          child: Center(
            child: Text(
              displayLabel,
              style: TextStyle(
                color: isSelected ? colorScheme.primary : colorScheme.onSurface,
                fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _handleContinue() {
    final template = PotluckTemplateModel(
      type: 'potluck',
      name: 'Potluck',
      emoji: 'ğŸ¦ƒ',
      maxDishesPerPerson: _maxDishesPerPerson,
      allowDuplicates: _allowDuplicates,
      dishes: _preFillSuggestions ? _getCommonDishes() : [],
    );

    Navigator.pop(context, template);
  }

  List<PotluckDish> _getCommonDishes() {
    // Pre-fill suggestions for Friendsgiving
    return [
      PotluckDish(
        id: _generateId(),
        name: 'Turkey',
        category: 'mains',
        description: 'Main course',
        servingSize: 'Feeds 8-10',
        dietaryInfo: [],
      ),
      PotluckDish(
        id: _generateId(),
        name: 'Stuffing',
        category: 'sides',
        servingSize: '9x13 pan',
        dietaryInfo: [],
      ),
      PotluckDish(
        id: _generateId(),
        name: 'Cranberry Sauce',
        category: 'sides',
        servingSize: '1 can',
        dietaryInfo: ['vegetarian', 'vegan'],
      ),
      PotluckDish(
        id: _generateId(),
        name: 'Pumpkin Pie',
        category: 'desserts',
        servingSize: '9-inch pie',
        dietaryInfo: ['vegetarian'],
      ),
      PotluckDish(
        id: _generateId(),
        name: 'Wine',
        category: 'drinks',
        servingSize: '1-2 bottles',
        dietaryInfo: [],
      ),
    ];
  }
}
```

---

### 2. Dish Signup List (Collaborative List)

**Location:** `lib/presentation/widgets/templates/potluck_dish_list.dart`

**Purpose:** Display categorized list of dishes with real-time claiming

**UI Structure:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  What to Bring                    + Add  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                          â”‚
â”‚  ğŸ½ï¸ MAINS (1/2 needed)                  â”‚
â”‚                                          â”‚
â”‚  âœ“  Turkey (Feeds 8-10)                  â”‚
â”‚      ğŸ‘¤ Mike Chen                        â”‚
â”‚      ğŸŒ± No dietary restrictions          â”‚
â”‚                                          â”‚
â”‚  â—‹  Ham (Optional)                       â”‚
â”‚      Available                           â”‚
â”‚      [Claim]                             â”‚
â”‚                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                          â”‚
â”‚  ğŸ¥— SIDES (2/4 needed)                   â”‚
â”‚                                          â”‚
â”‚  âœ“  Stuffing (9x13 pan)                  â”‚
â”‚      ğŸ‘¤ Emma Davis                       â”‚
â”‚                                          â”‚
â”‚  âœ“  Mashed Potatoes                      â”‚
â”‚      ğŸ‘¤ You                              â”‚
â”‚      ğŸŒ± Vegetarian                       â”‚
â”‚                                          â”‚
â”‚  â—‹  Green Bean Casserole                 â”‚
â”‚      Available                           â”‚
â”‚      [Claim]                             â”‚
â”‚                                          â”‚
â”‚  â—‹  Cranberry Sauce                      â”‚
â”‚      Available                           â”‚
â”‚      [Claim]                             â”‚
â”‚      ğŸŒ± Vegan, Gluten-Free               â”‚
â”‚                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                          â”‚
â”‚  ğŸ° DESSERTS (0/2 needed)                â”‚
â”‚                                          â”‚
â”‚  â—‹  Pumpkin Pie                          â”‚
â”‚      Available                           â”‚
â”‚      [Claim]                             â”‚
â”‚                                          â”‚
â”‚  â—‹  Apple Pie                            â”‚
â”‚      Available                           â”‚
â”‚      [Claim]                             â”‚
â”‚                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                          â”‚
â”‚  ğŸ¥¤ DRINKS (1/2 needed)                  â”‚
â”‚  ğŸ´ APPETIZERS (0/2 needed)              â”‚
â”‚                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Features:**
- **Category headers** with emoji and count (claimed/total)
- **Availability status**: âœ“ Claimed, â—‹ Available
- **Claim button** appears for available dishes (if user hasn't reached limit)
- **Real-time updates** when others claim dishes
- **Dietary icons** visible on items
- **Expand/collapse** categories (optional)

**Implementation:**
```dart
class PotluckDishList extends ConsumerWidget {
  final String eventId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final eventAsync = ref.watch(eventDetailProvider(eventId));

    return eventAsync.when(
      data: (event) {
        final template = event.potluckTemplate!;
        final categories = PotluckTemplateModel.standardCategories;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildHeader(context, ref),
            SizedBox(height: AppSpacing.md),

            // Render each category
            ...categories.map((category) {
              final dishes = template.getDishesByCategory(category);
              if (dishes.isEmpty) return SizedBox.shrink();

              return Column(
                children: [
                  _buildCategoryHeader(context, category, dishes),
                  ...dishes.map((dish) => _buildDishItem(context, ref, dish, template)),
                  SizedBox(height: AppSpacing.lg),
                ],
              );
            }),
          ],
        );
      },
      loading: () => Center(child: CircularProgressIndicator()),
      error: (error, stack) => ErrorView(error: error),
    );
  }

  Widget _buildCategoryHeader(BuildContext context, String category, List<PotluckDish> dishes) {
    final appColors = context.appColors;
    final claimedCount = dishes.where((d) => d.claimedBy != null).length;
    final totalCount = dishes.length;
    final emoji = _getCategoryEmoji(category);

    return Padding(
      padding: EdgeInsets.only(bottom: AppSpacing.md),
      child: Row(
        children: [
          Text(emoji, style: TextStyle(fontSize: 20)),
          SizedBox(width: AppSpacing.sm),
          Text(
            category.toUpperCase(),
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: appColors.textSecondary,
              letterSpacing: 0.5,
            ),
          ),
          SizedBox(width: AppSpacing.sm),
          Text(
            '($claimedCount/$totalCount ${totalCount == 1 ? "needed" : "needed"})',
            style: TextStyle(
              fontSize: 12,
              color: appColors.textMuted,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDishItem(
    BuildContext context,
    WidgetRef ref,
    PotluckDish dish,
    PotluckTemplateModel template,
  ) {
    final colorScheme = Theme.of(context).colorScheme;
    final appColors = context.appColors;
    final currentUserId = ref.watch(currentUserIdProvider);

    final isClaimed = dish.claimedBy != null;
    final isClaimedByMe = dish.claimedBy == currentUserId;
    final canClaim = !isClaimed && template.canUserAddDish(currentUserId);

    return Container(
      padding: EdgeInsets.all(AppSpacing.md),
      margin: EdgeInsets.only(bottom: AppSpacing.sm),
      decoration: BoxDecoration(
        color: isClaimed
          ? appColors.cardBackground.withValues(alpha: 0.5)
          : appColors.cardBackground,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: isClaimedByMe
            ? colorScheme.primary
            : isClaimed
              ? appColors.divider
              : appColors.cardBorder,
          width: isClaimedByMe ? 2 : 1,
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              // Status icon
              Icon(
                isClaimed ? Icons.check_circle : Icons.radio_button_unchecked,
                color: isClaimed ? appColors.success : appColors.textMuted,
                size: 20,
              ),
              SizedBox(width: AppSpacing.sm),

              // Dish name
              Expanded(
                child: Text(
                  dish.name,
                  style: TextStyle(
                    fontWeight: FontWeight.w600,
                    color: colorScheme.onSurface,
                    decoration: isClaimed ? TextDecoration.lineThrough : null,
                  ),
                ),
              ),

              // Claim button (if available and user can claim)
              if (canClaim)
                TextButton(
                  onPressed: () => _handleClaimDish(ref, dish.id),
                  style: TextButton.styleFrom(
                    padding: EdgeInsets.symmetric(horizontal: AppSpacing.md, vertical: AppSpacing.sm),
                    backgroundColor: colorScheme.primary.withValues(alpha: 0.1),
                  ),
                  child: Text('Claim'),
                ),

              // Unclaim button (if claimed by me)
              if (isClaimedByMe)
                TextButton(
                  onPressed: () => _handleUnclaimDish(ref, dish.id),
                  style: TextButton.styleFrom(
                    padding: EdgeInsets.symmetric(horizontal: AppSpacing.md, vertical: AppSpacing.sm),
                  ),
                  child: Text('Unclaim'),
                ),
            ],
          ),

          // Serving size
          if (dish.servingSize != null) ...[
            SizedBox(height: AppSpacing.xs),
            Text(
              dish.servingSize!,
              style: TextStyle(fontSize: 12, color: appColors.textSecondary),
            ),
          ],

          // Who claimed it
          if (isClaimed) ...[
            SizedBox(height: AppSpacing.xs),
            Row(
              children: [
                Icon(Icons.person, size: 14, color: appColors.textSecondary),
                SizedBox(width: 4),
                Text(
                  isClaimedByMe
                    ? 'You'
                    : _getUserName(ref, dish.claimedBy!),
                  style: TextStyle(fontSize: 12, color: appColors.textSecondary),
                ),
              ],
            ),
          ] else ...[
            SizedBox(height: AppSpacing.xs),
            Text(
              'Available',
              style: TextStyle(
                fontSize: 12,
                color: appColors.textMuted,
                fontStyle: FontStyle.italic,
              ),
            ),
          ],

          // Dietary info
          if (dish.dietaryInfo.isNotEmpty) ...[
            SizedBox(height: AppSpacing.xs),
            Wrap(
              spacing: AppSpacing.xs,
              children: dish.dietaryInfo.map((diet) => _buildDietaryChip(context, diet)).toList(),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildDietaryChip(BuildContext context, String dietary) {
    final appColors = context.appColors;

    final config = {
      'vegetarian': {'icon': 'ğŸŒ±', 'label': 'Vegetarian', 'color': Colors.green},
      'vegan': {'icon': 'ğŸŒ¿', 'label': 'Vegan', 'color': Colors.green.shade700},
      'gluten-free': {'icon': 'ğŸŒ¾', 'label': 'Gluten-Free', 'color': Colors.orange},
      'dairy-free': {'icon': 'ğŸ¥›', 'label': 'Dairy-Free', 'color': Colors.blue},
      'nut-free': {'icon': 'ğŸ¥œ', 'label': 'Nut-Free', 'color': Colors.brown},
    };

    final info = config[dietary] ?? {'icon': 'âœ“', 'label': dietary, 'color': Colors.grey};

    return Container(
      padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: (info['color'] as Color).withValues(alpha: 0.1),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(info['icon'] as String, style: TextStyle(fontSize: 10)),
          SizedBox(width: 4),
          Text(
            info['label'] as String,
            style: TextStyle(
              fontSize: 10,
              color: info['color'] as Color,
              fontWeight: FontWeight.w600,
            ),
          ),
        ],
      ),
    );
  }

  String _getCategoryEmoji(String category) {
    return {
      'mains': 'ğŸ½ï¸',
      'sides': 'ğŸ¥—',
      'desserts': 'ğŸ°',
      'drinks': 'ğŸ¥¤',
      'appetizers': 'ğŸ´',
    }[category] ?? 'ğŸ“¦';
  }

  Future<void> _handleClaimDish(WidgetRef ref, String dishId) async {
    final eventProvider = ref.read(eventDetailProvider(eventId).notifier);
    await eventProvider.claimPotluckDish(dishId);
  }

  Future<void> _handleUnclaimDish(WidgetRef ref, String dishId) async {
    final eventProvider = ref.read(eventDetailProvider(eventId).notifier);
    await eventProvider.unclaimPotluckDish(dishId);
  }
}
```

---

### 3. Add Dish Sheet (Modal Bottom Sheet)

**Location:** `lib/presentation/widgets/templates/add_potluck_dish_sheet.dart`

**Purpose:** Form to add new dish to potluck

**UI Structure:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Add Dish                         [X]    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                          â”‚
â”‚  DISH NAME *                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Green Bean Casserole               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                          â”‚
â”‚  CATEGORY *                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ [ğŸ½ï¸ Mains] [ğŸ¥— Sides] [ğŸ° Desserts] â”‚  â”‚
â”‚  â”‚ [ğŸ¥¤ Drinks] [ğŸ´ Appetizers]         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  Selected: Sides                         â”‚
â”‚                                          â”‚
â”‚  SERVING SIZE                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 9x13 pan                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  Examples: "Serves 8", "2 liters", etc. â”‚
â”‚                                          â”‚
â”‚  DESCRIPTION (OPTIONAL)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Classic casserole with crispy      â”‚  â”‚
â”‚  â”‚ fried onions on top                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                          â”‚
â”‚  DIETARY INFO                            â”‚
â”‚  [âœ“] Vegetarian   [ ] Vegan             â”‚
â”‚  [ ] Gluten-Free  [ ] Dairy-Free        â”‚
â”‚  [ ] Nut-Free                           â”‚
â”‚                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         Add Dish                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚     Add & Claim for Myself         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation:**
```dart
class AddPotluckDishSheet extends StatefulWidget {
  final String eventId;

  @override
  State<AddPotluckDishSheet> createState() => _AddPotluckDishSheetState();
}

class _AddPotluckDishSheetState extends State<AddPotluckDishSheet> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _servingSizeController = TextEditingController();
  final _descriptionController = TextEditingController();

  String _selectedCategory = 'sides';
  List<String> _selectedDietaryInfo = [];

  @override
  Widget build(BuildContext context) {
    return DraggableScrollableSheet(
      initialChildSize: 0.9,
      maxChildSize: 0.95,
      minChildSize: 0.5,
      builder: (context, scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
          ),
          child: Form(
            key: _formKey,
            child: Column(
              children: [
                _buildHeader(),
                Expanded(
                  child: ListView(
                    controller: scrollController,
                    padding: EdgeInsets.all(AppSpacing.lg),
                    children: [
                      _buildNameField(),
                      SizedBox(height: AppSpacing.lg),
                      _buildCategorySelector(),
                      SizedBox(height: AppSpacing.lg),
                      _buildServingSizeField(),
                      SizedBox(height: AppSpacing.lg),
                      _buildDescriptionField(),
                      SizedBox(height: AppSpacing.lg),
                      _buildDietaryCheckboxes(),
                    ],
                  ),
                ),
                _buildActionButtons(),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildCategorySelector() {
    final categories = PotluckTemplateModel.standardCategories;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'CATEGORY *',
          style: TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.w600,
            color: appColors.textSecondary,
            letterSpacing: 0.5,
          ),
        ),
        SizedBox(height: AppSpacing.sm),
        Wrap(
          spacing: AppSpacing.sm,
          runSpacing: AppSpacing.sm,
          children: categories.map((category) {
            final isSelected = _selectedCategory == category;
            final emoji = _getCategoryEmoji(category);

            return InkWell(
              onTap: () => setState(() => _selectedCategory = category),
              child: Container(
                padding: EdgeInsets.symmetric(horizontal: AppSpacing.md, vertical: AppSpacing.sm),
                decoration: BoxDecoration(
                  color: isSelected
                    ? colorScheme.primary.withValues(alpha: 0.1)
                    : appColors.cardBackground,
                  borderRadius: BorderRadius.circular(20),
                  border: Border.all(
                    color: isSelected ? colorScheme.primary : appColors.cardBorder,
                    width: isSelected ? 2 : 1,
                  ),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(emoji, style: TextStyle(fontSize: 16)),
                    SizedBox(width: 6),
                    Text(
                      category.capitalize(),
                      style: TextStyle(
                        color: isSelected ? colorScheme.primary : colorScheme.onSurface,
                        fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                      ),
                    ),
                  ],
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildDietaryCheckboxes() {
    final options = [
      'vegetarian',
      'vegan',
      'gluten-free',
      'dairy-free',
      'nut-free',
    ];

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'DIETARY INFO',
          style: TextStyle(
            fontSize: 12,
            fontWeight: FontWeight.w600,
            color: appColors.textSecondary,
            letterSpacing: 0.5,
          ),
        ),
        SizedBox(height: AppSpacing.sm),
        Wrap(
          spacing: AppSpacing.sm,
          runSpacing: AppSpacing.sm,
          children: options.map((option) {
            final isSelected = _selectedDietaryInfo.contains(option);

            return FilterChip(
              label: Text(option.capitalize()),
              selected: isSelected,
              onSelected: (selected) {
                setState(() {
                  if (selected) {
                    _selectedDietaryInfo.add(option);
                  } else {
                    _selectedDietaryInfo.remove(option);
                  }
                });
              },
              selectedColor: colorScheme.primary.withValues(alpha: 0.2),
              checkmarkColor: colorScheme.primary,
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildActionButtons() {
    return Padding(
      padding: EdgeInsets.all(AppSpacing.lg),
      child: Column(
        children: [
          // Add dish only
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: _handleAddDish,
              style: ElevatedButton.styleFrom(
                backgroundColor: colorScheme.primary,
                padding: EdgeInsets.symmetric(vertical: AppSpacing.md),
              ),
              child: Text('Add Dish'),
            ),
          ),

          SizedBox(height: AppSpacing.sm),

          // Add and claim
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              onPressed: _handleAddAndClaim,
              style: OutlinedButton.styleFrom(
                padding: EdgeInsets.symmetric(vertical: AppSpacing.md),
              ),
              child: Text('Add & Claim for Myself'),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _handleAddDish() async {
    if (!_formKey.currentState!.validate()) return;

    final dish = PotluckDish(
      id: _generateId(),
      name: _nameController.text.trim(),
      category: _selectedCategory,
      description: _descriptionController.text.trim().isEmpty
        ? null
        : _descriptionController.text.trim(),
      servingSize: _servingSizeController.text.trim().isEmpty
        ? null
        : _servingSizeController.text.trim(),
      dietaryInfo: _selectedDietaryInfo,
      claimedBy: null,
    );

    Navigator.pop(context, {'dish': dish, 'claimNow': false});
  }

  Future<void> _handleAddAndClaim() async {
    if (!_formKey.currentState!.validate()) return;

    final currentUserId = ref.read(currentUserIdProvider);

    final dish = PotluckDish(
      id: _generateId(),
      name: _nameController.text.trim(),
      category: _selectedCategory,
      description: _descriptionController.text.trim().isEmpty
        ? null
        : _descriptionController.text.trim(),
      servingSize: _servingSizeController.text.trim().isEmpty
        ? null
        : _servingSizeController.text.trim(),
      dietaryInfo: _selectedDietaryInfo,
      claimedBy: currentUserId,
      claimedAt: DateTime.now(),
    );

    Navigator.pop(context, {'dish': dish, 'claimNow': true});
  }
}
```

---

### 4. Potluck Summary Card

**Location:** `lib/presentation/widgets/templates/potluck_summary_card.dart`

**Purpose:** Display overview of potluck status (used in event detail screen)

**UI Structure:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ“Š Potluck Status                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                          â”‚
â”‚  12 dishes total                         â”‚
â”‚  8 claimed, 4 still needed               â”‚
â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘  67%        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                          â”‚
â”‚  BY CATEGORY:                            â”‚
â”‚  ğŸ½ï¸ Mains: 2/3                          â”‚
â”‚  ğŸ¥— Sides: 4/5                           â”‚
â”‚  ğŸ° Desserts: 1/2                        â”‚
â”‚  ğŸ¥¤ Drinks: 1/2                          â”‚
â”‚                                          â”‚
â”‚  YOUR DISHES:                            â”‚
â”‚  â€¢ Mashed Potatoes (Sides)              â”‚
â”‚                                          â”‚
â”‚  [View Full List]                        â”‚
â”‚                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation:**
```dart
class PotluckSummaryCard extends ConsumerWidget {
  final String eventId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final event = ref.watch(eventDetailProvider(eventId)).value;
    if (event?.potluckTemplate == null) return SizedBox.shrink();

    final template = event!.potluckTemplate!;
    final totalDishes = template.dishes.length;
    final claimedDishes = template.dishes.where((d) => d.claimedBy != null).length;
    final percentageClaimed = totalDishes > 0 ? (claimedDishes / totalDishes * 100).round() : 0;

    final currentUserId = ref.watch(currentUserIdProvider);
    final myDishes = template.dishes.where((d) => d.claimedBy == currentUserId).toList();

    return Container(
      padding: EdgeInsets.all(AppSpacing.lg),
      decoration: BoxDecoration(
        color: appColors.cardBackground,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: appColors.cardBorder),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'ğŸ“Š POTLUCK STATUS',
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.w600,
              color: appColors.textSecondary,
              letterSpacing: 0.5,
            ),
          ),
          SizedBox(height: AppSpacing.md),

          Text(
            '$totalDishes ${totalDishes == 1 ? "dish" : "dishes"} total',
            style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
          ),
          Text(
            '$claimedDishes claimed, ${totalDishes - claimedDishes} still needed',
            style: TextStyle(color: appColors.textSecondary),
          ),

          SizedBox(height: AppSpacing.md),

          // Progress bar
          ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: LinearProgressIndicator(
              value: percentageClaimed / 100,
              minHeight: 20,
              backgroundColor: appColors.divider,
              valueColor: AlwaysStoppedAnimation(
                percentageClaimed == 100 ? appColors.success : colorScheme.primary,
              ),
            ),
          ),

          SizedBox(height: AppSpacing.lg),

          // Category breakdown
          Text(
            'BY CATEGORY:',
            style: TextStyle(
              fontSize: 11,
              fontWeight: FontWeight.w600,
              color: appColors.textSecondary,
            ),
          ),
          SizedBox(height: AppSpacing.sm),
          ...PotluckTemplateModel.standardCategories.map((category) {
            final dishes = template.getDishesByCategory(category);
            if (dishes.isEmpty) return SizedBox.shrink();

            final claimed = dishes.where((d) => d.claimedBy != null).length;
            final total = dishes.length;
            final emoji = _getCategoryEmoji(category);

            return Padding(
              padding: EdgeInsets.only(bottom: 4),
              child: Text(
                '$emoji ${category.capitalize()}: $claimed/$total',
                style: TextStyle(color: appColors.textSecondary),
              ),
            );
          }),

          // My dishes
          if (myDishes.isNotEmpty) ...[
            SizedBox(height: AppSpacing.md),
            Text(
              'YOUR DISHES:',
              style: TextStyle(
                fontSize: 11,
                fontWeight: FontWeight.w600,
                color: appColors.textSecondary,
              ),
            ),
            SizedBox(height: AppSpacing.sm),
            ...myDishes.map((dish) => Padding(
              padding: EdgeInsets.only(bottom: 4),
              child: Text(
                'â€¢ ${dish.name} (${dish.category.capitalize()})',
                style: TextStyle(color: appColors.textSecondary),
              ),
            )),
          ],

          SizedBox(height: AppSpacing.md),

          // View full list button
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              onPressed: () => _navigateToFullList(context),
              child: Text('View Full List'),
            ),
          ),
        ],
      ),
    );
  }
}
```

---

### 5. Real-Time Updates Provider

**Location:** `lib/presentation/providers/event_detail_provider.dart` (extend existing)

**Purpose:** Handle dish claiming with optimistic updates and real-time subscriptions

**Implementation:**
```dart
@riverpod
class EventDetail extends _$EventDetail {
  @override
  Future<EventModel> build(String eventId) async {
    final eventService = ref.watch(eventServiceProvider);
    final event = await eventService.getEventById(eventId);

    // Subscribe to real-time updates if potluck template
    if (event.isPotluck) {
      _subscribeToTemplateUpdates(eventId);
    }

    return event;
  }

  void _subscribeToTemplateUpdates(String eventId) {
    // Listen for changes to template_data column
    final subscription = supabase
      .from('events')
      .stream(primaryKey: ['id'])
      .eq('id', eventId)
      .listen((data) {
        if (data.isNotEmpty) {
          final updatedEvent = EventModel.fromJson(data.first);
          state = AsyncValue.data(updatedEvent);
        }
      });

    // Store subscription for cleanup
    ref.onDispose(() => subscription.cancel());
  }

  // Potluck dish management
  Future<void> claimPotluckDish(String dishId) async {
    final currentEvent = await future;
    if (currentEvent.potluckTemplate == null) return;

    final currentUserId = supabase.auth.currentUser!.id;
    final template = currentEvent.potluckTemplate!;

    // Check if user can claim more dishes
    if (!template.canUserAddDish(currentUserId)) {
      throw Exception('You have reached your dish limit');
    }

    // Optimistic update
    final updatedDishes = template.dishes.map((dish) {
      if (dish.id == dishId) {
        return dish.copyWith(
          claimedBy: currentUserId,
          claimedAt: DateTime.now(),
        );
      }
      return dish;
    }).toList();

    final updatedTemplate = template.copyWith(dishes: updatedDishes);

    state = AsyncValue.data(
      currentEvent.copyWith(templateData: updatedTemplate),
    );

    // Persist to backend
    try {
      final eventService = ref.read(eventServiceProvider);
      await eventService.updateEvent(
        eventId,
        templateData: updatedTemplate.toJson(),
      );
    } catch (e) {
      // Rollback on error
      state = AsyncValue.data(currentEvent);
      rethrow;
    }
  }

  Future<void> unclaimPotluckDish(String dishId) async {
    final currentEvent = await future;
    if (currentEvent.potluckTemplate == null) return;

    final template = currentEvent.potluckTemplate!;

    // Optimistic update
    final updatedDishes = template.dishes.map((dish) {
      if (dish.id == dishId) {
        return dish.copyWith(
          claimedBy: null,
          claimedAt: null,
        );
      }
      return dish;
    }).toList();

    final updatedTemplate = template.copyWith(dishes: updatedDishes);

    state = AsyncValue.data(
      currentEvent.copyWith(templateData: updatedTemplate),
    );

    // Persist to backend
    try {
      final eventService = ref.read(eventServiceProvider);
      await eventService.updateEvent(
        eventId,
        templateData: updatedTemplate.toJson(),
      );
    } catch (e) {
      // Rollback on error
      state = AsyncValue.data(currentEvent);
      rethrow;
    }
  }

  Future<void> addPotluckDish(PotluckDish dish) async {
    final currentEvent = await future;
    if (currentEvent.potluckTemplate == null) return;

    final template = currentEvent.potluckTemplate!;

    // Optimistic update
    final updatedTemplate = template.addDish(
      name: dish.name,
      category: dish.category,
      description: dish.description,
      servingSize: dish.servingSize,
      dietaryInfo: dish.dietaryInfo,
      claimedBy: dish.claimedBy,
    );

    state = AsyncValue.data(
      currentEvent.copyWith(templateData: updatedTemplate),
    );

    // Persist to backend
    final eventService = ref.read(eventServiceProvider);
    await eventService.updateEvent(
      eventId,
      templateData: updatedTemplate.toJson(),
    );
  }

  Future<void> removePotluckDish(String dishId) async {
    final currentEvent = await future;
    if (currentEvent.potluckTemplate == null) return;

    final template = currentEvent.potluckTemplate!;

    // Optimistic update
    final updatedTemplate = template.removeDish(dishId);

    state = AsyncValue.data(
      currentEvent.copyWith(templateData: updatedTemplate),
    );

    // Persist to backend
    final eventService = ref.read(eventServiceProvider);
    await eventService.updateEvent(
      eventId,
      templateData: updatedTemplate.toJson(),
    );
  }
}
```

---

## Integration Points

### 1. Event Creation Flow

**Modified:** `lib/presentation/screens/event_creation_screen.dart`

```dart
void _applyTemplate(EventTemplate template) {
  if (template == EventTemplate.friendsgiving) {
    // Show configuration sheet
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => PotluckConfigSheet(
        groupId: widget.groupId!,
      ),
    ).then((result) {
      if (result != null && result is PotluckTemplateModel) {
        setState(() {
          _selectedTemplate = template;
          _templateData = result;
          _titleController.text = 'Friendsgiving';
          _emoji = 'ğŸ¦ƒ';
        });
      }
    });
  }
}
```

### 2. Event Detail Screen

**Modified:** `lib/presentation/screens/event_detail_screen.dart`

```dart
Widget build(BuildContext context, WidgetRef ref) {
  final eventAsync = ref.watch(eventDetailProvider(eventId));

  return eventAsync.when(
    data: (event) {
      if (event.isPotluck) {
        return Scaffold(
          appBar: AppBar(title: Text(event.title)),
          body: ListView(
            padding: EdgeInsets.all(AppSpacing.lg),
            children: [
              _buildEventDetailsCard(event),
              SizedBox(height: AppSpacing.lg),
              PotluckSummaryCard(eventId: eventId),
              SizedBox(height: AppSpacing.lg),
              PotluckDishList(eventId: eventId),
            ],
          ),
          floatingActionButton: FloatingActionButton(
            onPressed: () => _showAddDishSheet(context, ref),
            child: Icon(Icons.add),
          ),
        );
      }

      // Normal event rendering
      return _buildNormalEventDetail(event);
    },
    loading: () => Center(child: CircularProgressIndicator()),
    error: (error, stack) => ErrorView(error: error),
  );
}

void _showAddDishSheet(BuildContext context, WidgetRef ref) {
  showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    backgroundColor: Colors.transparent,
    builder: (context) => AddPotluckDishSheet(eventId: eventId),
  ).then((result) {
    if (result != null && result is Map) {
      final dish = result['dish'] as PotluckDish;
      final eventProvider = ref.read(eventDetailProvider(eventId).notifier);
      eventProvider.addPotluckDish(dish);
    }
  });
}
```

---

## Acceptance Criteria

### Issue #71: Backend (Already Complete âœ…)
- [x] `events.template_data` JSONB column exists
- [x] `PotluckTemplateModel` with helper methods
- [x] RLS policies enforce data access

### Issue #72: UI Implementation (This Plan)

**Template Configuration:**
- [ ] `PotluckConfigSheet` modal bottom sheet
- [ ] Max dishes per person selector (1, 2, 3, unlimited)
- [ ] Allow duplicates toggle
- [ ] Pre-fill suggestions option
- [ ] Validation before continuing

**Dish List Display:**
- [ ] `PotluckDishList` widget displays all dishes
- [ ] Category headers with emoji and count
- [ ] Claim/unclaim buttons functional
- [ ] Real-time updates when others claim dishes
- [ ] Dietary info chips displayed
- [ ] Availability status clear (claimed vs available)

**Add Dish Functionality:**
- [ ] `AddPotluckDishSheet` modal bottom sheet
- [ ] Category selector with icons
- [ ] Dietary info checkboxes
- [ ] Two action buttons: "Add Dish" and "Add & Claim"
- [ ] Validation (name and category required)

**Summary Card:**
- [ ] `PotluckSummaryCard` shows overall progress
- [ ] Progress bar with percentage
- [ ] Category breakdown counts
- [ ] User's claimed dishes listed
- [ ] "View Full List" navigation button

**State Management:**
- [ ] Real-time subscription on events table
- [ ] `claimPotluckDish()` method with optimistic update
- [ ] `unclaimPotluckDish()` method with optimistic update
- [ ] `addPotluckDish()` method
- [ ] `removePotluckDish()` method
- [ ] Rollback on error

**User Limits:**
- [ ] Enforce max dishes per person
- [ ] Hide claim button when limit reached
- [ ] Show snackbar when user tries to exceed limit
- [ ] Allow duplicate dish names if enabled

---

## Testing Checklist

### Manual Testing Scenarios

**Scenario 1: Create Potluck Event**
1. Go to event creation screen
2. Tap "ğŸ¦ƒ Friendsgiving" template chip
3. Config sheet opens
4. Select max dishes: 2
5. Toggle duplicates: ON
6. Enable pre-fill suggestions
7. Tap "Continue to Dishes"
8. Verify template applied with 5 pre-filled dishes
9. Save event
10. Verify dishes saved in template_data

**Scenario 2: Claim Dishes**
1. Open potluck event
2. Verify sees dish list with categories
3. Tap "Claim" on "Mashed Potatoes"
4. Verify dish immediately shows as claimed by me
5. Verify UI updates (checkmark, "You")
6. Claim second dish
7. Verify claim button hidden on other dishes (limit reached)
8. Tap "Unclaim" on first dish
9. Verify claim buttons reappear

**Scenario 3: Add New Dish**
1. Tap "+" FAB
2. Add Dish sheet opens
3. Enter name: "Mac and Cheese"
4. Select category: Sides
5. Enter serving size: "Feeds 10"
6. Select dietary: Vegetarian
7. Tap "Add & Claim for Myself"
8. Verify dish added to list
9. Verify auto-claimed by me
10. Verify saved to backend

**Scenario 4: Real-Time Collaboration**
1. User A opens potluck event
2. User B (different device) opens same event
3. User A claims "Turkey"
4. Verify User B sees "Turkey" update to claimed in real-time
5. Verify claim button disappears for User B
6. User B claims "Stuffing"
7. Verify User A sees update

**Scenario 5: Dish Limits**
1. Create potluck with max 2 dishes
2. User claims 2 dishes
3. Verify all claim buttons disappear
4. Verify snackbar: "You've reached your dish limit"
5. Unclaim 1 dish
6. Verify claim buttons reappear

---

## Files to Create/Modify

### New Files
- `lib/presentation/widgets/templates/potluck_config_sheet.dart` (~250 lines)
- `lib/presentation/widgets/templates/potluck_dish_list.dart` (~350 lines)
- `lib/presentation/widgets/templates/add_potluck_dish_sheet.dart` (~300 lines)
- `lib/presentation/widgets/templates/potluck_summary_card.dart` (~200 lines)

### Modified Files
- `lib/presentation/screens/event_creation_screen.dart` (add config sheet trigger)
- `lib/presentation/screens/event_detail_screen.dart` (add potluck rendering)
- `lib/presentation/providers/event_detail_provider.dart` (add potluck methods, real-time)

**Total New Code:** ~1,100 lines
**Total Modified Code:** ~150 lines

---

## Timeline

**Week 7, Day 4 (February 10):**
- Create `PotluckConfigSheet` (2 hours)
- Create `AddPotluckDishSheet` (2 hours)
- Test configuration and add dish flows (1 hour)

**Week 7, Day 5 (February 11):**
- Create `PotluckDishList` (3 hours)
- Create `PotluckSummaryCard` (1.5 hours)
- Implement real-time subscriptions (1.5 hours)
- Full integration testing (1 hour)

**Total:** 9-11 hours

---

## Success Metrics

- [ ] Users can create potluck in <1 minute
- [ ] Claiming updates in <200ms (optimistic)
- [ ] Real-time updates arrive in <1 second
- [ ] 0 race conditions when multiple users claim simultaneously
- [ ] 95%+ of testers understand dish claiming flow
- [ ] Category breakdown motivates balanced contributions

---

## Notes

- **Database already implemented** - Pure UI focus
- **Real-time critical** - Must feel collaborative and instant
- **Optimistic updates** - Show changes immediately, rollback on error
- **Dietary info important** - Clear visual indicators prevent issues
- **Category organization** - Ensures balanced meal
- **Follow SignUpGenius patterns** - Users familiar with this UX
