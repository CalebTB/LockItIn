# Potluck Template - UI Implementation Plan (UPDATED WITH LESSONS LEARNED)

**Issues:** #71, #72
**Sprint:** 4, Week 7 (February 10-11, 2026)
**Estimated Time:** 12-14 hours total (increased from 9-11 to account for proper testing)
**Focus:** Flutter UI, Collaborative Lists, Real-time Updates
**Updated:** 2026-01-14 - Incorporates lessons from Surprise Party post-mortem

---

## ‚ö†Ô∏è CRITICAL: Lessons Learned from Surprise Party Implementation

**Post-Mortem Grade: D+** (30% development time wasted on preventable mistakes)

Before implementing this feature, you **MUST** read:

üìñ **[Flutter + Supabase Critical Patterns](../docs/solutions/patterns/flutter-supabase-critical-patterns.md)**

This document contains 9 essential patterns that prevent the mistakes made during Surprise Party implementation.

### Summary of Required Patterns

1. **Read Existing Code BEFORE Implementing** - Search codebase first, never start coding without research
2. **Clarify Requirements Upfront** - Ask questions before building, don't assume
3. **Don't Use JSONB in RLS Policies** - Use indexed tables for relationships
4. **Update Single Record in State** - Don't re-fetch all data on every realtime update
5. **Use Provider for Complex Features** - Proper lifecycle management with dispose()
6. **Check Database Config BEFORE Writing Client Code** - Verify realtime publications, RLS policies
7. **Test with Realistic Data** - Test with 12+, 50+, 100+ items, not just 1-2
8. **Hot Reload ‚â† Full Restart** - Database changes require full app restart
9. **Implement All UI States** - Loading, empty, error, and success states

### Pre-Implementation Checklist

**MANDATORY - If ANY checkbox is unchecked, STOP and complete it before writing code:**

- [ ] **Read existing code** - Searched for similar patterns (`surprise_party_*`, `add_task_sheet`, `DraggableScrollableSheet`)
- [ ] **Clarify requirements** - Asked about permissions, access model, edge cases
- [ ] **Check database config** - Verified RLS policies, realtime publication, indexes exist
- [ ] **Create realistic test data** - Created test events with 0, 1, 12, 50+, 100+ dishes
- [ ] **Review architecture** - Considered performance, scalability, state management
- [ ] **Follow existing patterns** - Match naming conventions from Surprise Party template
- [ ] **Document decisions** - Explain WHY in comments and migrations
- [ ] **Test all UI states** - Loading, empty, error, success implemented for every async operation

---

## Critical Data Model Issue (MUST RESOLVE FIRST)

**‚ö†Ô∏è BLOCKER:** The plan's code examples use fields that don't exist in the actual `PotluckDish` model!

### Spec Says (from plan):
```dart
class PotluckDish {
  final String id;
  final String name;              // ‚ùå DOESN'T EXIST
  final String category;
  final String? description;       // ‚ùå DOESN'T EXIST
  final String? servingSize;
  final List<String> dietaryInfo;  // ‚ùå WRONG TYPE (actual is String?)
  final String? claimedBy;         // ‚ùå DOESN'T EXIST
  final DateTime? claimedAt;       // ‚ùå DOESN'T EXIST
}
```

### Actual Model (from `event_template_model.dart:340-378`):
```dart
class PotluckDish {
  final String id;
  final String category;
  final String dishName;           // ‚úÖ (not "name")
  final String userId;             // ‚úÖ (not "claimedBy", NOT NULLABLE)
  final int? servingSize;          // ‚úÖ (int, not String)
  final String? dietaryNotes;      // ‚úÖ (String, not List<String>)

  // MISSING FIELDS:
  // - description
  // - dietaryInfo List
  // - claimedAt timestamp
}
```

### Required Resolution Before Implementation:

**Option A: Update Data Model (Recommended)**

Add migration to expand `PotluckDish`:

```dart
class PotluckDish {
  final String id;
  final String category;
  final String dishName;
  final String? userId;              // MAKE NULLABLE (unclaimed dishes)
  final String? description;         // ADD
  final String? servingSize;         // CHANGE to String
  final List<String> dietaryInfo;    // ADD (structured list)
  final DateTime? claimedAt;         // ADD

  // BREAKING CHANGES:
  // 1. userId: String ‚Üí String? (nullable for unclaimed)
  // 2. servingSize: int? ‚Üí String? (flexible user input)
  // 3. dietaryNotes: String? ‚Üí List<String> dietaryInfo (structured)
  // 4. Add description field
  // 5. Add claimedAt field
}
```

**Option B: Update Plan to Match Existing Model**

Rewrite all UI code to use:
- `dishName` instead of `name`
- `userId` instead of `claimedBy` (but still can't represent unclaimed!)
- `dietaryNotes` as free-form text (no checkboxes)
- No description field
- No claimed timestamp

**Decision Required:** Which option?

**Recommendation:** Option A - Update model to match spec. The spec's design is superior (nullable claimer, structured dietary info, timestamps).

---

## Critical Gaps Identified (From Spec-Flow Analysis)

### Race Condition Handling

**Problem:** User A and B both claim "Ham" simultaneously

**Solution Needed:**
```dart
Future<void> claimPotluckDish(String dishId) async {
  // ... optimistic update ...

  try {
    // Use RPC with version check to detect concurrent updates
    final result = await supabase.rpc('claim_dish_with_version', params: {
      'dish_id': dishId,
      'user_id': currentUserId,
      'event_id': eventId,
      'expected_version': currentVersion,
    });

    if (!result['success']) {
      throw Exception('This dish was just claimed by someone else!');
    }
  } catch (e) {
    // Rollback optimistic update
    state = previousState;

    // User-friendly error
    throw Exception('Failed to claim dish: ${e.message}');
  }
}
```

### Unlimited Dishes Logic Bug

**Problem:** `maxDishesPerPerson = 0` means unlimited, but `canUserAddDish()` checks `count < max` (always false!)

**Fix:**
```dart
bool canUserAddDish(String userId) {
  if (maxDishesPerPerson == 0) return true;  // Unlimited case
  return getUserDishCount(userId) < maxDishesPerPerson;
}
```

### Real-Time Subscription Lifecycle

**Problem:** Spec shows subscription in `build()` ‚Üí Memory leak!

**Fix:** Move to `initState()` with `dispose()` cleanup:
```dart
@override
void initState() {
  super.initState();
  _loadInitialDishes();
  _subscribeToTemplateUpdates();  // After initial load
}

@override
void dispose() {
  _dishesChannel?.unsubscribe();  // Critical cleanup
  super.dispose();
}
```

### Backend Validation Missing

**Problem:** Client-only validation can be bypassed via API

**Solution:** Add RLS policy + database constraint:
```sql
-- Prevent exceeding dish limit
CREATE OR REPLACE FUNCTION check_dish_limit()
RETURNS TRIGGER AS $$
DECLARE
  max_dishes INTEGER;
  current_count INTEGER;
BEGIN
  -- Get max dishes setting from event template
  SELECT (template_data->>'maxDishesPerPerson')::INTEGER INTO max_dishes
  FROM events WHERE id = NEW.event_id;

  -- Skip if unlimited (0 or NULL)
  IF max_dishes IS NULL OR max_dishes = 0 THEN
    RETURN NEW;
  END IF;

  -- Count user's current dishes
  SELECT COUNT(*) INTO current_count
  FROM jsonb_array_elements(
    (SELECT template_data->'dishes' FROM events WHERE id = NEW.event_id)
  ) AS dish
  WHERE dish->>'userId' = NEW.user_id;

  IF current_count >= max_dishes THEN
    RAISE EXCEPTION 'User has reached dish limit';
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Note: This is a placeholder - actual trigger depends on final data structure
```

### Empty States Missing

**Required:**
- Empty dish list ‚Üí "No dishes yet. Tap + to add the first one!"
- Empty category ‚Üí Show category header with "Add dish" CTA
- All dishes claimed ‚Üí Success confetti + "Potluck complete! üéâ"
- User at limit ‚Üí Info banner "You've claimed your 2 dishes"

---

## Research Findings Summary

### Existing Infrastructure to Reuse

**Surprise Party Template Patterns** (MUST follow these):

1. **Config Sheet** (`surprise_party_config_sheet.dart:80-604`)
   - `DraggableScrollableSheet` with `initialChildSize: 0.9`
   - Fixed header + scrollable content + sticky footer
   - Returns configured template via `Navigator.pop(context, template)`

2. **Task List Widget** (`surprise_party_task_list.dart:68-485`)
   - Section headers with counts
   - Card-based items with checkbox/unclaim pattern
   - More menu modal for additional actions
   - Member selection modal (radio buttons)

3. **Add Task Sheet** (`add_task_sheet.dart:47-377`)
   - Form with validation
   - Text inputs + selection UI
   - Provider pattern for state updates

4. **Real-Time Pattern** (`surprise_party_dashboard_screen.dart:85-128`)
   - Subscribe in `initState()` (NOT `build()`!)
   - `if (!mounted)` guard in callbacks
   - `unsubscribe()` in `dispose()`

### Theme System (MUST use these)

```dart
final colorScheme = Theme.of(context).colorScheme;
final appColors = context.appColors;

// NEVER hardcode colors
colorScheme.primary        // Rose accent
colorScheme.surface        // Background
colorScheme.onSurface      // Primary text
appColors.cardBackground   // Card bg
appColors.cardBorder       // Card border
appColors.textSecondary    // Muted text
appColors.success          // Green (for claimed)
```

### Real-Time Best Practices (From Research)

1. **Use Broadcast for Collaborative Features** (not Postgres Changes)
   - Scales better (250K concurrent users)
   - Lower latency (6ms median)
   - No RLS performance bottleneck

2. **Optimistic Updates with Rollback**
   - Apply change immediately in UI
   - Send server request
   - Rollback on error with user-friendly message

3. **Debounce Rapid Updates**
   - Batch updates every 500ms for high-frequency changes
   - Prevents overwhelming UI with rapid state changes

4. **Memory Management**
   - Always `unsubscribe()` in `dispose()`
   - Check `if (!mounted)` before `setState()` in async callbacks
   - Persist streams as StatefulWidget variables (not in `build()`)

---

## Implementation Plan (Revised)

### Phase 1: Data Model Resolution (2 hours)

**Tasks:**
1. Review actual `PotluckDish` model fields
2. Decide: Update model or update plan?
3. If updating model:
   - Write migration to add missing fields
   - Update `PotluckTemplateModel` helper methods
   - Update tests for new fields
4. Document decision in plan

**Deliverables:**
- Data model alignment confirmed
- Migration script (if needed)
- Updated helper methods

### Phase 2: Database Verification (1 hour)

**Tasks:**
1. Check if `events` table is in `supabase_realtime` publication:
   ```sql
   SELECT * FROM pg_publication_tables
   WHERE pubname = 'supabase_realtime'
   AND tablename = 'events';
   ```
2. If not, add it:
   ```sql
   ALTER PUBLICATION supabase_realtime ADD TABLE events;
   ```
3. Verify RLS policies allow template_data updates:
   ```sql
   \d+ events  -- Check policies
   ```
4. Test with realistic data (12+ dishes, multiple users)

**Deliverables:**
- Realtime enabled confirmation
- RLS policies verified
- Test data created

### Phase 3: UI Components (6 hours)

#### 3A: PotluckConfigSheet (2 hours)

**Pattern:** Copy structure from `SurprisePartyConfigSheet`

**Implementation Steps:**
1. Read `surprise_party_config_sheet.dart` (Lines 80-604)
2. Copy `DraggableScrollableSheet` structure
3. Adapt sections:
   - Max dishes selector (radio buttons, not free input)
   - Allow duplicates toggle (Switch widget)
   - Pre-fill suggestions toggle
4. Validation before return
5. Test with all permutations (2/3/unlimited, duplicates on/off)

**Testing:**
- [ ] All max dish options selectable
- [ ] Duplicates toggle works
- [ ] Pre-fill adds correct dishes (5 items)
- [ ] Form validates before closing

#### 3B: PotluckDishList (2.5 hours)

**Pattern:** Follow `SurprisePartyTaskList` structure

**Critical Patterns:**
1. **Section headers with counts:**
   ```dart
   Text('$emoji ${category.toUpperCase()} ($claimed/$total)')
   ```
2. **Card-based items:**
   ```dart
   Container(
     decoration: BoxDecoration(
       color: appColors.cardBackground,
       border: Border.all(
         color: isClaimedByMe ? colorScheme.primary : appColors.cardBorder,
         width: isClaimedByMe ? 2 : 1,
       ),
     ),
   )
   ```
3. **Optimistic updates:**
   ```dart
   // Update UI immediately
   setState(() => _optimisticClaims[dishId] = true);

   // Then update backend
   try {
     await provider.claimDish(dishId);
   } catch (e) {
     setState(() => _optimisticClaims.remove(dishId));  // Rollback
     ScaffoldMessenger.of(context).showSnackBar(...);
   }
   ```

**Testing with Realistic Data:**
- [ ] Test with 0 dishes (empty state)
- [ ] Test with 1 dish (minimal case)
- [ ] Test with 12 dishes (typical potluck)
- [ ] Test with 50+ dishes (scrollable, no overflow)
- [ ] Test with 100+ dishes (performance check)

#### 3C: AddPotluckDishSheet (1.5 hours)

**Pattern:** Copy from `AddTaskSheet`

**Key Features:**
1. Form validation (name + category required)
2. Category selector (chip-based, like Surprise Party member selector)
3. Dietary checkboxes (structured List, not free-form)
4. Two submit buttons:
   - "Add Dish" (unclaimed)
   - "Add & Claim for Myself" (auto-claim)

**Testing:**
- [ ] Required field validation works
- [ ] Dietary checkboxes multi-select
- [ ] Both submit buttons work correctly
- [ ] Form clears after submit

### Phase 4: State Management & Real-Time (3 hours)

#### 4A: Provider Setup (1.5 hours)

**Pattern:** Extend `CalendarProvider` OR create `PotluckProvider`

**Critical Pattern (from research):**
```dart
class PotluckProvider extends ChangeNotifier {
  final SupabaseClient _supabase = Supabase.instance.client;

  RealtimeChannel? _channel;
  bool _isRealtimeActive = false;

  // State
  List<PotluckDish> _dishes = [];
  bool _isLoading = false;
  String? _error;

  Future<void> subscribe(String eventId) async {
    _isLoading = true;
    notifyListeners();

    try {
      // 1. Fetch initial data FIRST
      await _fetchDishes(eventId);

      // 2. THEN subscribe to updates
      _setupRealtimeSubscription(eventId);

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _error = _getUserFriendlyError(e);
      _isLoading = false;
      notifyListeners();
    }
  }

  void _setupRealtimeSubscription(String eventId) {
    _channel = _supabase.channel('event-$eventId');

    _channel!
      .onPostgresChanges(
        event: PostgresChangeEvent.update,
        schema: 'public',
        table: 'events',
        filter: PostgresChangeFilter(
          type: PostgresChangeFilterType.eq,
          column: 'id',
          value: eventId,
        ),
        callback: (payload) {
          // Update SINGLE record, don't re-fetch all
          final updatedEvent = EventModel.fromJson(payload.newRecord!);
          _dishes = updatedEvent.potluckTemplate?.dishes ?? [];
          notifyListeners();
        },
      )
      .subscribe((status, error) {
        if (status == RealtimeSubscribeStatus.subscribed) {
          _isRealtimeActive = true;
          notifyListeners();
        } else if (status == RealtimeSubscribeStatus.closed) {
          _isRealtimeActive = false;
          notifyListeners();
        }
      });
  }

  @override
  void dispose() {
    _channel?.unsubscribe();  // CRITICAL: Always cleanup
    super.dispose();
  }
}
```

#### 4B: Real-Time Testing (1.5 hours)

**Test Scenarios:**
1. **Two users, one dish:**
   - User A claims "Turkey"
   - User B sees update within 1 second
   - No full app restart required

2. **Race condition:**
   - User A and B both tap "Claim" on "Ham" simultaneously
   - One succeeds, one gets error message
   - Loser's optimistic update rolls back

3. **Connection loss:**
   - Disconnect wifi
   - Attempt to claim dish
   - See error message (not silent failure)
   - Reconnect wifi
   - Verify subscription resumes automatically

4. **Hot reload vs Full restart:**
   - Make database migration (add column to events)
   - Try hot reload ‚Üí Subscription doesn't see new column
   - Full restart ‚Üí Subscription works correctly

**Deliverables:**
- [ ] Real-time updates <1s latency
- [ ] Race condition handled gracefully
- [ ] Network errors show user-friendly messages
- [ ] Subscription cleanup prevents memory leaks

### Phase 5: Integration & Testing (2 hours)

#### 5A: Event Creation Integration

**Modify:** `event_creation_screen.dart`

**Pattern:**
```dart
void _applyTemplate(EventTemplate template) {
  if (template == EventTemplate.friendsgiving) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => PotluckConfigSheet(),
    ).then((result) {
      if (result != null && result is PotluckTemplateModel) {
        setState(() {
          _templateData = result;
          _titleController.text = 'Friendsgiving';
          _emoji = 'ü¶É';
        });
      }
    });
  }
}
```

#### 5B: Event Detail Integration

**Modify:** `event_detail_screen.dart`

**Pattern:**
```dart
Widget build(BuildContext context) {
  if (_event.isPotluck) {
    return Scaffold(
      body: ListView(
        children: [
          _buildEventDetailsCard(),
          PotluckSummaryCard(eventId: widget.eventId),
          PotluckDishList(eventId: widget.eventId),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showAddDishSheet,
        child: Icon(Icons.add),
      ),
    );
  }

  return _buildNormalEventDetail();
}
```

#### 5C: Full Integration Test

**Test Complete User Journey:**
1. Create new event
2. Select "ü¶É Friendsgiving" template
3. Configure (max 2 dishes, duplicates on, pre-fill yes)
4. Save event
5. Open event detail
6. See 5 pre-filled dishes
7. Claim 2 dishes
8. Try to claim 3rd ‚Üí See limit message
9. Add new dish "Mac and Cheese"
10. Claim it (should fail - already at limit)
11. Unclaim one dish
12. Claim "Mac and Cheese" (should succeed)
13. Open on second device
14. Verify sees all changes in real-time

**Performance Benchmarks:**
- [ ] Claim action feels instant (<200ms optimistic update)
- [ ] Real-time update arrives <1s
- [ ] List of 50+ dishes scrolls smoothly
- [ ] No memory leaks (check DevTools after 10 claims/unclaims)

---

## Acceptance Criteria (Updated)

### Data Model
- [ ] `PotluckDish` model matches implementation (fields aligned)
- [ ] Unclaimed dishes representable (`userId` nullable OR separate `isClaimed` field)
- [ ] Unlimited dishes logic works (`maxDishesPerPerson = 0` handled)

### Database Config (VERIFY BEFORE CLIENT CODE)
- [ ] `events` table in `supabase_realtime` publication
- [ ] RLS policies allow template_data updates for group members
- [ ] Indexes exist on `events(id)` for real-time filtering
- [ ] Backend validation enforces dish limits (RLS or trigger)

### UI Components (All States)
- [ ] **PotluckConfigSheet:**
  - Max dishes selector works (1/2/3/unlimited)
  - Duplicates toggle functional
  - Pre-fill adds 5 dishes
  - Validation before close
- [ ] **PotluckDishList:**
  - Empty state shown when no dishes
  - Loading skeleton during fetch
  - Error state with retry button
  - Success state with categorized dishes
  - Scrollable (no overflow with 50+ dishes)
- [ ] **AddPotluckDishSheet:**
  - Form validation (name + category required)
  - Dietary checkboxes multi-select
  - Two submit buttons work
- [ ] **PotluckSummaryCard:**
  - Progress bar accurate
  - Category counts correct
  - User's dishes listed
  - "View Full List" scrolls to dish list

### Real-Time & State Management
- [ ] Subscription in `initState()` (not `build()`)
- [ ] `dispose()` calls `unsubscribe()` (memory cleanup)
- [ ] `if (!mounted)` guard in callbacks
- [ ] Optimistic updates with rollback on error
- [ ] Single record updated (not re-fetch all)
- [ ] Race conditions handled with user-friendly errors
- [ ] Connection loss shows error (not silent failure)

### Performance
- [ ] Initial load <2s for 50 dishes
- [ ] Optimistic updates <200ms
- [ ] Real-time updates arrive <1s
- [ ] No memory leaks (DevTools profiler)
- [ ] Smooth scrolling with 100+ dishes

### Testing
- [ ] Tested with 0 dishes (empty state)
- [ ] Tested with 1 dish (minimal)
- [ ] Tested with 12 dishes (typical)
- [ ] Tested with 50+ dishes (scrolling)
- [ ] Tested with 100+ dishes (performance)
- [ ] Tested race conditions (2 users, 1 dish)
- [ ] Tested offline behavior (claim fails gracefully)
- [ ] Tested hot reload vs full restart (knows when to restart)

### Documentation
- [ ] Migration comments explain WHY (not just WHAT)
- [ ] Provider methods documented with examples
- [ ] Widget documentation includes usage
- [ ] Known issues documented (e.g., offline limitations)

---

## Files to Create/Modify

### New Files
- `lib/presentation/widgets/templates/potluck_config_sheet.dart` (~250 lines)
- `lib/presentation/widgets/templates/potluck_dish_list.dart` (~400 lines - includes all states)
- `lib/presentation/widgets/templates/add_potluck_dish_sheet.dart` (~300 lines)
- `lib/presentation/widgets/templates/potluck_summary_card.dart` (~200 lines)
- `lib/presentation/providers/potluck_provider.dart` (~300 lines - if separate from CalendarProvider)

### Modified Files
- `lib/data/models/event_template_model.dart` (update PotluckDish fields if Option A chosen)
- `lib/presentation/screens/event_creation_screen.dart` (add config sheet trigger)
- `lib/presentation/screens/event_detail_screen.dart` (add potluck rendering)
- `lib/presentation/providers/calendar_provider.dart` (add potluck methods if not separate provider)

### Database Changes (If Updating Model)
- New migration: `020_update_potluck_dish_fields.sql`
  - Make `userId` nullable
  - Add `claimedAt` timestamp logic
  - Update helper functions

**Total New Code:** ~1,450 lines
**Total Modified Code:** ~200 lines

---

## Timeline (Revised)

**Week 7, Day 3 (February 9):**
- Resolve data model alignment (2 hours)
- Database verification (1 hour)

**Week 7, Day 4 (February 10):**
- Create `PotluckConfigSheet` (2 hours)
- Create `AddPotluckDishSheet` (1.5 hours)
- Create `PotluckProvider` setup (1.5 hours)

**Week 7, Day 5 (February 11):**
- Create `PotluckDishList` with all states (2.5 hours)
- Create `PotluckSummaryCard` (1 hour)
- Real-time testing scenarios (1.5 hours)
- Full integration testing (2 hours)

**Total:** 12-14 hours (realistic with proper testing)

---

## Success Metrics

- [ ] Users can create potluck in <1 minute
- [ ] Claiming updates in <200ms (optimistic)
- [ ] Real-time updates arrive in <1 second
- [ ] 0 race conditions (loser gets error message)
- [ ] 95%+ of testers understand flow without explanation
- [ ] No memory leaks after 50 claim/unclaim cycles
- [ ] Works with 100+ dishes (no performance degradation)
- [ ] Network errors handled gracefully (user knows what happened)

---

## Anti-Patterns to Avoid (From Required Reading)

### ‚ùå DON'T:
1. Start coding without reading `surprise_party_*.dart` files
2. Assume requirements (ask about permissions, limits, edge cases)
3. Use JSONB for dish claims (update on template_data is unavoidable here, but minimize queries)
4. Re-fetch all dishes on every realtime update
5. Subscribe to realtime in `build()` method
6. Test with only 1-2 dishes
7. Assume hot reload works after database migrations
8. Skip empty/error/loading states
9. Use manual `setState()` for complex state (use Provider)
10. Forget to call `unsubscribe()` in `dispose()`

### ‚úÖ DO:
1. Search codebase for similar patterns before coding
2. Ask clarifying questions about access model, limits
3. Verify database config (realtime publication) BEFORE client code
4. Update single record in state (not full re-fetch)
5. Subscribe in `initState()`, cleanup in `dispose()`
6. Test with 0, 1, 12, 50+, 100+ dishes
7. Full restart after database migrations
8. Implement all 4 states for every async operation
9. Use Provider pattern for subscriptions
10. Guard callbacks with `if (!mounted)`

---

## Post-Implementation Review

After completing implementation, document:

1. **What went well:**
   - Patterns followed from Surprise Party
   - Performance benchmarks met

2. **Issues encountered:**
   - Race conditions discovered
   - Unexpected edge cases

3. **Technical debt created:**
   - Known limitations
   - Future optimization opportunities

4. **Grade:** (Self-assess: A/B/C/D/F based on time wasted on rework)

Target: **B or higher** (minimal rework, most patterns followed on first attempt)
